# 受驱单摆的非线性动力学实验报告

## 1. 实验目的

简要描述本实验的主要目标：
1. 实现并比较不同数值方法求解受驱单摆方程的效果
2. 研究受驱单摆系统的共振现象
3. 分析系统在不同参数下的混沌行为

## 2. 理论背景

### 2.1 受驱单摆方程

简要介绍受驱单摆的运动方程及其物理意义：
- 方程的推导过程
  A:受驱单摆的运动方程是一个经典的非线性微分方程，描述了在重力和外部驱动力作用下的摆动行为。其方程形式为：![1748590870230(1)](https://github.com/user-attachments/assets/2dcc9bc5-6ef0-438f-95c9-a68912c9b257)
  

- 各项参数的物理含义
  A:其中：θ 是摆角（弧度）t 是时间（秒）g 是重力加速度（通常取 9.81m/s^2）ℓ 是摆长（米）C 是驱动力强度系数（s^−2）Ω 是驱动力的角频率（s^−1）该方程考虑了重力和外部驱动力的影响，其中非线性项 sinθ 和 cosθ 导致了复杂的动力学行为。
- 无量纲化处理（如果使用）
### 2.2 数值方法

简要说明使用的数值方法原理：
1. 欧拉法
   - 基本原理:欧拉法是一种简单的一阶数值方法，通过泰勒展开的前两项来近似微分方程的解。
   - 误差阶数:一阶精度。
   - 优缺点:实现简单，但精度较低，稳定性较差。

2. 改进欧拉法
   - 改进的思路:通过预测-校正的方式提高精度。
   - 误差阶数:二阶精度。
   - 与简单欧拉法的比较:精度更高，稳定性更好，但计算量稍大。

3. 四阶龙格-库塔法
   - 方法原理:通过四个斜率的加权平均来近似解，具有较高的精度。
   - 误差阶数:四阶精度。
   - 计算效率分析:虽然计算量较大，但精度高，稳定性好，适用于复杂系统的求解。

## 3. 实验方法

### 3.1 代码实现

简要说明各个函数的实现思路：
1. `forced_pendulum_ode`函数
   - 实现要点：定义受驱单摆的常微分方程，返回摆角和角速度的导数。
   - 关键步骤说明：根据运动方程计算dθ/dt和 dω/dt。

2. 数值求解方法
   - 欧拉法实现要点：通过简单的迭代公式更新摆角和角速度。
   - 改进欧拉法实现要点：通过预测和校正步骤提高精度。
   - RK4方法实现要点：计算四个斜率并取加权平均，适用于复杂系统的高精度求解。

### 3.2 实验参数

列出实验中使用的主要参数：
- 阻尼系数 γ
- 驱动频率 ω_d
- 驱动力幅度 F_d
- 初始条件
- 时间步长
- 驱动力幅度 C=8.5 s^-2
- 模拟时间范围：t∈[0,400]s

## 4. 实验结果与分析

### 4.1 数值方法比较

1. 不同方法的数值解比较
   - 插入时间序列图
     ![image](https://github.com/user-attachments/assets/6f9a2511-c13c-43e3-af20-8613b0f89804)

   - 分析三种方法的计算结果差异：欧拉法的解在长时间模拟中误差较大，改进欧拉法和RK4法的解更为准确。
   - 讨论数值稳定性：RK4法在精度和稳定性方面表现最佳。

2. 计算效率比较
   Euler Method Time: 0.0410 seconds
   Improved Euler Method Time: 0.0710 seconds
   RK4 Method Time: 0.1788 seconds
   solve_ivp (RK45) Time: 0.1375 seconds
   - 比较不同方法的计算时间：比较了三种方法的计算时间，发现欧拉法最快，但精度最低；RK4法虽然计算量大，但精度最高。
   - 分析精度和效率的权衡：由此若注重效率，选择欧拉法；若注重精度，选择RK4法。

### 4.2 共振现象分析
![1748590331246](https://github.com/user-attachments/assets/bfd451c5-6f85-4806-b065-05fd3cd7c935)

1. 共振曲线
   - 插入幅频特性图
     ![image](https://github.com/user-attachments/assets/2e909127-3502-4f33-bf4a-4de9422813e7)
    ![1748590331246(1)](https://github.com/user-attachments/assets/f16ea659-1425-4372-a00b-f3e5e4866a4c)

   - 分析共振频率：共振频率约为 Ω_0= (g/ℓ)^(1/2)，阻尼会降低共振峰的高度。
   - 讨论阻尼对共振的影响:阻尼会降低系统的能量，从而降低共振峰的高度。阻尼越大，共振峰越宽，系统对驱动力频率的变化越不敏感。

2. 特征分析
   - 描述观察到的共振特征：观察到在共振频率附近，系统振幅显著增大。
   - 与理论预期的比较：实验结果与理论预期一致，验证了数值方法的准确性。

### 4.3 混沌行为研究

1. 相空间分析
   - 插入相空间图
     ![image](https://github.com/user-attachments/assets/f7796537-f6e4-4836-99db-33ac10b7083c)

   - 描述轨道特征
     A:相空间图显示了摆角和角速度之间的关系。在混沌条件下，轨迹充满某个区域，不形成闭合曲线。混沌行为通常在非线性系统中出现，当驱动力足够强时。
   - 分析混沌的产生条件
     A:混沌行为通常在非线性系统中出现，当驱动力足够强时。混沌的产生还与系统的初始条件、参数设置等因素有关。在相空间图中，混沌行为表现为轨迹的无规则填充，不形成闭合曲线。

2. 参数依赖性
   - 不同参数下的系统行为：通过改变驱动力强度 C 和驱动力频率 Ω，观察到系统从周期性行为过渡到混沌行为。
   - 混沌转捩的特征：当驱动力强度超过某一临界值时，系统出现混沌现象。

## 5. 讨论

1. 数值方法的适用性
   - 各方法的优缺点：欧拉法简单但精度低；改进欧拉法在精度和计算量之间取得平衡；RK4法适用于需要高精度的复杂系统。
   - 最佳方法的选择建议：根据问题的复杂性和对精度的要求选择合适的数值方法。

2. 物理现象的解释
   - 共振机理：共振现象是由于驱动力频率与系统固有频率匹配，导致能量持续输入系统。
   - 混沌产生的机制：混沌现象源于系统的非线性特性，驱动力强度和频率的改变会导致系统行为的显著变化。
   - 与其他物理系统的类比：类似现象在其他非线性系统（如电路、流体动力学）中也会出现。

3. 实验中遇到的问题和解决方法
   - 数值计算中的困难：在长时间模拟中，低精度方法容易出现数值发散。
   - 参数选择的考虑：选择合适的驱动力强度和频率是观察混沌现象的关键。
   - 改进建议：进一步优化数值方法，提高计算效率和精度。

## 6. 结论

总结实验的主要发现：
1.数值方法的比较结果：RK4法在精度和稳定性方面表现最佳，适用于复杂系统的求解。
2. 受驱单摆的动力学特征：系统在特定参数下表现出共振和混沌行为。
3. 共振和混沌现象的主要特点A:共振现象表现为在特定频率下振幅显著增大。混沌现象表现为相空间轨迹的无规则填充，系统行为对初始条件敏感。

## 7. 参考文献

列出参考的文献资料：
1. 教材和参考书
2. 相关论文
3. 网络资源

## 附录：核心代码

附上关键函数的代码实现（建议只包含最核心的部分）：

```python
def forced_pendulum_ode(t, state, l, g, C, Omega):
    theta, omega = state
    dtheta_dt = omega
    domega_dt = - (g / l) * np.sin(theta) + C * np.cos(theta) * np.sin(Omega * t)
    return [dtheta_dt, domega_dt]

def solve_pendulum(l=0.1, g=9.81, C=2, Omega=5, t_span=(0,100), y0=[0,0]):
    t_eval = np.linspace(t_span[0], t_span[1], 2000)
    sol = solve_ivp(
        fun=forced_pendulum_ode,
        t_span=t_span,
        y0=y0,
        args=(l, g, C, Omega),
        dense_output=True,
        t_eval=t_eval
    )
    return sol.t, sol.y[0]

def find_resonance(l=0.1, g=9.81, C=2, Omega_range=None, t_span=(0,200), y0=[0,0]):
    if Omega_range is None:
        Omega_0 = np.sqrt(g / l)
        Omega_range = np.linspace(Omega_0 / 2, 2 * Omega_0, 50)  # 确保返回50个点
    
    amplitudes = []
    
    for Omega in Omega_range:
        t, theta = solve_pendulum(l, g, C, Omega, t_span, y0)
        
        steady_idx = t > t_span[0] + (t_span[1]-t_span[0])/2
        amplitude = np.max(np.abs(theta[steady_idx]))
        amplitudes.append(amplitude)
    
    return Omega_range, amplitudes
```
